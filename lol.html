<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>SimpleMessenger Sync (single file)</title>
<style>
  :root{--bg:#0f1724;--panel:#0b1220;--accent:#5865f2;--muted:#98a0b3;--msg:#e6eef8;--self:#2f9a4a;--danger:#e04b4b}
  *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071021 0%,var(--bg) 100%);color:var(--msg)}
  .app{display:flex;height:100vh;gap:16px;padding:18px}
  .sidebar{width:300px;background:var(--panel);border-radius:10px;padding:12px;display:flex;flex-direction:column;gap:12px}
  .brand{font-weight:700;color:var(--accent);font-size:18px}
  .channels,.users{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;max-height:180px;overflow:auto}
  .user-row{display:flex;align-items:center;gap:8px;padding:6px;border-radius:6px}
  .avatar{width:36px;height:36px;border-radius:50%;object-fit:cover;border:1px solid rgba(255,255,255,0.04)}
  .channel{padding:8px;border-radius:6px;cursor:pointer;color:var(--muted)}
  .channel.active{background:rgba(88,101,242,0.12);color:var(--msg);font-weight:600}
  .main{flex:1;display:flex;flex-direction:column;gap:12px}
  .header{background:var(--panel);padding:12px;border-radius:10px;display:flex;justify-content:space-between;align-items:center}
  .chat{flex:1;background:var(--panel);padding:12px;border-radius:10px;display:flex;flex-direction:column;gap:10px;overflow:auto}
  .messages{display:flex;flex-direction:column;gap:8px}
  .msg-row{display:flex;align-items:flex-start;gap:8px;position:relative}
  .msg{max-width:70%;padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.03);color:var(--msg);position:relative}
  .msg.me{margin-left:auto;background:linear-gradient(90deg,var(--self),#36b36a);color:#fff}
  .msg.hidden{opacity:0.85;background:rgba(255,255,255,0.02);font-style:italic;color:var(--muted)}
  .composer{display:flex;gap:8px;align-items:center}
  input[type="text"],input[type="password"],textarea{background:#071827;border:1px solid rgba(255,255,255,0.03);color:var(--msg);padding:10px;border-radius:8px;outline:none;width:100%}
  button{background:var(--accent);color:#fff;padding:8px 12px;border:0;border-radius:8px;cursor:pointer}
  .muted{color:var(--muted);font-size:13px}
  .auth{position:fixed;inset:0;background:rgba(2,6,12,0.6);display:flex;align-items:center;justify-content:center}
  .card{background:linear-gradient(180deg,#071426,#061021);padding:18px;border-radius:12px;width:520px;box-shadow:0 10px 30px rgba(2,6,20,0.5)}
  label{display:block;font-size:13px;margin-bottom:6px;color:var(--muted)}
  .row{display:flex;gap:8px}
  .small{font-size:13px}
  .channels .channel:hover{background:rgba(255,255,255,0.02)}
  footer{color:var(--muted);font-size:12px;text-align:center;margin-top:8px}
  .msg-img{max-width:320px;border-radius:8px;display:block;margin-top:8px;cursor:pointer;border:1px solid rgba(255,255,255,0.04)}
  a.msg-link{color: #9ec1ff; text-decoration:underline; word-break:break-all}
  .img-preview{max-height:56px;max-width:56px;border-radius:6px;object-fit:cover;margin-right:8px;border:1px solid rgba(255,255,255,0.04)}
  .compose-left{display:flex;align-items:center;gap:8px}
  .three-dots{background:transparent;border:0;color:var(--muted);cursor:pointer;font-size:18px;padding:4px;border-radius:6px}
  .three-dots:hover{background:rgba(255,255,255,0.02);color:var(--msg)}
  .menu{position:fixed;z-index:999;background:linear-gradient(180deg,#081223,#071018);border:1px solid rgba(255,255,255,0.04);padding:6px;border-radius:8px;min-width:170px;box-shadow:0 6px 18px rgba(2,6,20,0.6)}
  .menu button{display:block;text-align:left;width:100%;background:transparent;color:var(--msg);padding:8px;border-radius:6px;border:0;cursor:pointer}
  .menu button:hover{background:rgba(255,255,255,0.02)}
  .menu .danger{color:var(--danger)}
  .placeholder-hidden{padding:10px 12px;border-radius:8px;background:rgba(255,255,255,0.01);color:var(--muted);font-size:14px}
  .msg-meta{font-size:13px;color:var(--muted);margin-bottom:6px}
  .profile-actions{display:flex;gap:8px;align-items:center;margin-top:8px}
  .small-muted{font-size:12px;color:var(--muted)}
  .notice{font-size:12px;color:var(--muted);margin-top:6px}
</style>
<!-- Socket.io client (used only if SERVER_URL provided) -->
<script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
</head>
<body>
<div class="app">
  <aside class="sidebar">
    <div class="brand">SimpleMessenger Sync</div>
    <div class="muted">–¢–µ–∫—É—â–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</div>
    <div style="display:flex;align-items:center;gap:8px;">
      <img id="sidebarAvatar" class="avatar" src="" alt="avatar"/>
      <div><div id="currentUser" class="small">‚Äî</div><div id="currentUserBio" class="small-muted">‚Äî</div></div>
    </div>

    <div>
      <div class="muted" style="margin-bottom:6px">–ö–∞–Ω–∞–ª—ã</div>
      <div id="channels" class="channels"></div>
    </div>
    <div>
      <div class="muted" style="margin-bottom:6px">–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏</div>
      <div id="users" class="users"></div>
    </div>
    <div style="margin-top:auto">
      <button id="btnOpenProfile">–ü—Ä–æ—Ñ–∏–ª—å</button>
      <button id="btnLogout" style="background:#2b2b2b;margin-top:8px">–í—ã–π—Ç–∏</button>
      <div id="syncNotice" class="notice"></div>
    </div>
  </aside>

  <main class="main">
    <div class="header">
      <div>
        <div id="channelTitle">#general</div>
        <div class="muted small" id="channelDesc">–û–±—â–∏–π –∫–∞–Ω–∞–ª</div>
      </div>
      <div class="muted small" id="serverTime"></div>
    </div>

    <div class="chat">
      <div class="messages" id="messages"></div>
    </div>

    <div class="composer">
      <div class="compose-left">
        <input id="imageFile" type="file" accept="image/*" style="display:none" />
        <img id="imgPreview" class="img-preview" style="display:none" alt="preview" />
        <button id="btnAttach" title="–ü—Ä–∏–∫—Ä–µ–ø–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ">üìé</button>
      </div>
      <input id="inputMessage" type="text" placeholder="–ù–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–ª–∏ –≤—Å—Ç–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É..." />
      <button id="btnSend">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
    </div>
    <footer>–†–∞–±–æ—Ç–∞–µ—Ç —Å —Å–µ—Ä–≤–µ—Ä–æ–º —á–µ—Ä–µ–∑ Socket.io –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω SERVER_URL; –±–µ–∑ —Å–µ—Ä–≤–µ—Ä–∞ ‚Äî –ª–æ–∫–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º (–≤–∫–ª–∞–¥–∫–∏)</footer>
  </main>
</div>

<!-- –ú–æ–¥–∞–ª / profile -->
<div id="auth" class="auth">
  <div class="card">
    <h3 id="authTitle">–í—Ö–æ–¥ / –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è</h3>
    <div id="forms">
      <div id="loginForm">
        <label>–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
          <input id="loginUser" type="text" />
        </label>
        <label>–ü–∞—Ä–æ–ª—å
          <input id="loginPass" type="password" />
        </label>
        <div class="row" style="align-items:center;margin-top:8px">
          <label style="flex:1"><input id="rememberMe" type="checkbox" /> <span class="small muted">–ó–∞–ø–æ–º–Ω–∏—Ç—å –º–µ–Ω—è</span></label>
          <button id="btnLogin">–í–æ–π—Ç–∏</button>
        </div>
        <div style="margin-top:8px" class="muted small">–ï—â–µ –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã? <a href="#" id="toRegister">–°–æ–∑–¥–∞—Ç—å –∞–∫–∫–∞—É–Ω—Ç</a></div>
      </div>

      <div id="registerForm" style="display:none">
        <label>–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
          <input id="regUser" type="text" />
        </label>
        <label>–ü–∞—Ä–æ–ª—å
          <input id="regPass" type="password" />
        </label>
        <label>–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å
          <input id="regPass2" type="password" />
        </label>

        <label>–ê–≤–∞—Ç–∞—Ä (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
          <input id="regAvatarFile" type="file" accept="image/*" />
        </label>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="btnRegister">–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å</button>
          <button id="toLogin" style="background:#2b2b2b">–ù–∞–∑–∞–¥</button>
        </div>
        <div id="regMsg" class="muted small" style="margin-top:8px"></div>
      </div>

      <div id="profileForm" style="display:none">
        <label>–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
          <input id="profileUser" type="text" disabled />
        </label>
        <label>–ê–≤–∞—Ç–∞—Ä
          <div style="display:flex;align-items:center;gap:8px">
            <img id="profileAvatarPreview" class="avatar" src="" alt="preview"/>
            <div>
              <input id="profileAvatarFile" type="file" accept="image/*" />
              <div class="profile-actions">
                <button id="btnSaveAvatar">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                <button id="btnRemoveAvatar" style="background:#2b2b2b">–£–¥–∞–ª–∏—Ç—å</button>
              </div>
            </div>
          </div>
        </label>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="btnCloseProfile" style="background:#2b2b2b">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
      </div>

    </div>
  </div>
</div>

<script>
/* ===================== CONFIG =====================
 - –ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å —Å–µ—Ä–≤–µ—Ä (Node.js –∏–∑ –ø—Ä–∏–º–µ—Ä–∞), —É–∫–∞–∂–∏—Ç–µ –µ–≥–æ URL –≤ SERVER_URL.
 - –ï—Å–ª–∏ –æ—Å—Ç–∞–≤–∏—Ç—å –ø—É—Å—Ç—ã–º, –∫–ª–∏–µ–Ω—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ –ª–æ–∫–∞–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ (localStorage + BroadcastChannel/storage).
================================================== */
const SERVER_URL = ''; // –ø—Ä–∏–º–µ—Ä 'https://your-server.example.com' –∏–ª–∏ '' –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞

/* ===================== Utilities ===================== */
async function sha256Hex(str){
  const enc = new TextEncoder().encode(str);
  const hash = await crypto.subtle.digest('SHA-256', enc);
  return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join('');
}
function qs(id){return document.getElementById(id)}
function escapeHtml(s){ return s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;') }

/* ======= DEFAULT AVATAR (SVG data URL) ======= */
const DEFAULT_AVATAR = (()=>{
  const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='128' height='128' viewBox='0 0 24 24' fill='none'><rect width='24' height='24' rx='4' fill='%233a3f47'/><path d='M12 12a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 2c-3.3 0-6 1.7-6 3v1h12v-1c0-1.3-2.7-3-6-3z' fill='%23fff' opacity='0.92'/></svg>`;
  return 'data:image/svg+xml;base64,' + btoa(svg);
})();

/* ======= Storage keys ======= */
const USERS_KEY = 'sm_users_v3';
const MESSAGES_KEY = 'sm_messages_v3';
const APP_KEY = 'sm_app_v3';
const TOKEN_KEY = 'sm_token_v3';

/* ======= State ======= */
let users = loadJSON(USERS_KEY, {}); // { username: { hash, createdAt, avatar } } // avatar: dataURL or URL
let messages = loadJSON(MESSAGES_KEY, { general: [] }); // { channel: [ msg ] }
let appState = loadJSON(APP_KEY, { lastChannel: 'general' });
let currentUser = null;
let token = localStorage.getItem(TOKEN_KEY) || null;

/* ======= UI refs ======= */
const authModal = qs('auth');
const loginForm = qs('loginForm');
const registerForm = qs('registerForm');
const profileForm = qs('profileForm');
const btnLogin = qs('btnLogin');
const btnRegister = qs('btnRegister');
const btnLogout = qs('btnLogout');
const btnSend = qs('btnSend');
const inputMessage = qs('inputMessage');
const messagesWrap = qs('messages');
const channelsWrap = qs('channels');
const usersWrap = qs('users');
const currentUserLabel = qs('currentUser');
const currentUserBio = qs('currentUserBio');
const sidebarAvatar = qs('sidebarAvatar');
const channelTitle = qs('channelTitle');
const serverTime = qs('serverTime');
const rememberCheck = qs('rememberMe');

const imageFile = qs('imageFile');
const btnAttach = qs('btnAttach');
const imgPreview = qs('imgPreview');

const regAvatarFile = qs('regAvatarFile');
const profileAvatarFile = qs('profileAvatarFile');
const profileAvatarPreview = qs('profileAvatarPreview');
const profileUserInput = qs('profileUser');

const btnOpenProfile = qs('btnOpenProfile');
const btnCloseProfile = qs('btnCloseProfile');
const btnSaveAvatar = qs('btnSaveAvatar');
const btnRemoveAvatar = qs('btnRemoveAvatar');
const syncNotice = qs('syncNotice');

/* ======= Channels ======= */
const CHANNELS = [
  {id:'general', name:'#general', desc:'–û–±—â–∏–π –∫–∞–Ω–∞–ª'},
  {id:'random', name:'#random', desc:'–ë–æ–ª—Ç–∞–ª–∫–∞ –∏ –º–µ–º—ã'},
  {id:'dev', name:'#dev', desc:'–û–±—Å—É–∂–¥–µ–Ω–∏–µ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏'}
];

/* ======= Linkify (URL -> <a>) ======= */
function linkify(text){
  const urlRegex = /((https?:\/\/|www\.)[^\s<>"']+)/gi;
  return escapeHtml(text).replace(urlRegex, (m)=>{
    let url = m;
    if(!/^https?:\/\//i.test(url)) url = 'http://' + url;
    return `<a class="msg-link" href="${url}" target="_blank" rel="noopener noreferrer">${escapeHtml(m)}</a>`;
  });
}

/* ======= Helpers ======= */
function loadJSON(k, fallback){ try{ const v=localStorage.getItem(k); return v?JSON.parse(v):fallback }catch(e){return fallback} }
function saveJSON(k,v){ localStorage.setItem(k, JSON.stringify(v)); }
function ensureChannel(ch){ if(!messages[ch]) messages[ch]=[]; }
function saveMessages(){ saveJSON(MESSAGES_KEY, messages); }
function saveUsers(){ saveJSON(USERS_KEY, users); }
function saveApp(){ saveJSON(APP_KEY, appState); }
function saveToken(t){ token = t; if(t) localStorage.setItem(TOKEN_KEY, t); else localStorage.removeItem(TOKEN_KEY); }

function randomSuffix(){ return Math.random().toString(36).slice(2,9); }
function createMessageObject(user, text, image){
  const ts = Date.now();
  return { id: `${ts}-${randomSuffix()}`, user, text: text||'', image: image||null, ts, hidden: false };
}
function msgIndexById(channel, id){ ensureChannel(channel); return messages[channel].findIndex(m=>m.id===id); }

/* ======= Avatar utilities ======= */
function getUserAvatar(username){
  if(!username) return DEFAULT_AVATAR;
  const u = users[username];
  return (u && u.avatar) ? u.avatar : DEFAULT_AVATAR;
}
function readFileAsDataURL(file){
  return new Promise((res, rej)=>{
    const r = new FileReader();
    r.onload = ()=> res(r.result);
    r.onerror = ()=> rej(new Error('File read error'));
    r.readAsDataURL(file);
  });
}

/* ================= REALTIME LAYER =================
 - If SERVER_URL set, client will use Socket.io + REST to sync across devices.
 - If SERVER_URL empty or server unreachable, client uses local fallback:
     BroadcastChannel (fast within same origin) + storage events for other windows.
==================================================== */
let socket = null;
let usingServer = false;
let bc = null;

async function connectRealtime(){
  if(!SERVER_URL) return startLocalRealtime();
  // try to connect to socket.io server
  try {
    socket = io(SERVER_URL, { query: { token }, transports: ['websocket','polling'], autoConnect: false, reconnectionAttempts: 5 });
    // set up handlers
    socket.on('connect', ()=> {
      usingServer = true;
      syncNotice.textContent = '–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è: —Å–µ—Ä–≤–µ—Ä';
      // join current channel
      socket.emit('join', appState.lastChannel || 'general');
    });
    socket.on('connect_error', (err)=>{
      // failed to connect -> fallback
      usingServer = false;
      syncNotice.textContent = '–°–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –ª–æ–∫–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º';
      startLocalRealtime();
    });
    socket.on('message', ({channel, message})=>{
      ensureChannel(channel);
      if(!messages[channel].some(m=>m.id===message.id)){
        messages[channel].push(message);
        saveMessages();
        renderMessages();
      }
    });
    socket.on('message_deleted', ({channel, id})=>{
      const idx = msgIndexById(channel, id);
      if(idx !== -1){ messages[channel].splice(idx,1); saveMessages(); renderMessages(); }
    });
    socket.on('message_updated', ({channel, message})=>{
      const idx = msgIndexById(channel, message.id);
      if(idx !== -1){ messages[channel][idx] = message; saveMessages(); renderMessages(); }
    });
    socket.open();
    // quick ping to check viability (fallback if not open soon)
    setTimeout(()=>{ if(!socket.connected){ usingServer=false; connectRealtime(); } }, 2000);
  } catch(e){
    usingServer = false;
    startLocalRealtime();
  }
}

function startLocalRealtime(){
  usingServer = false;
  syncNotice.textContent = '–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è: –ª–æ–∫–∞–ª—å–Ω–∞—è (–≤–∫–ª–∞–¥–∫–∏)';
  try { bc = new BroadcastChannel('sm_broadcast_v3'); bc.onmessage = (ev)=> handleLocalBroadcast(ev.data); } catch(e){ bc = null; }
  window.addEventListener('storage', (ev)=>{
    if(ev.key === 'sm_last_broadcast_v3' && ev.newValue) {
      try{ const env = JSON.parse(ev.newValue); handleLocalBroadcast(env); } catch(e){}
    }
    if(ev.key === USERS_KEY && ev.newValue){ try{ users = JSON.parse(ev.newValue); renderUsers(); }catch(e){} }
    if(ev.key === MESSAGES_KEY && ev.newValue){ try{ messages = JSON.parse(ev.newValue); renderMessages(); }catch(e){} }
  });
}
function handleLocalBroadcast(env){
  if(!env) return;
  if(env.type === 'new_message'){ const { channel, message } = env; ensureChannel(channel); if(!messages[channel].some(m=>m.id===message.id)){ messages[channel].push(message); saveMessages(); renderMessages(); } }
  if(env.type === 'delete_message'){ const { channel, id } = env; const idx = msgIndexById(channel,id); if(idx!==-1){ messages[channel].splice(idx,1); saveMessages(); renderMessages(); } }
  if(env.type === 'update_message'){ const { channel, message } = env; const idx = msgIndexById(channel,message.id); if(idx!==-1){ messages[channel][idx] = message; saveMessages(); renderMessages(); } }
}
function broadcastLocal(env){
  try{ if(bc) bc.postMessage(env); localStorage.setItem('sm_last_broadcast_v3', JSON.stringify(env)); } catch(e){}
}

/* ================= Render functions ================= */
let activeMenu = null;
document.addEventListener('click', (e)=>{ if(activeMenu && !activeMenu.contains(e.target)) { activeMenu.remove(); activeMenu=null; } });

function renderChannels(){
  channelsWrap.innerHTML = '';
  CHANNELS.forEach(ch=>{
    const div = document.createElement('div');
    div.className = 'channel' + (appState.lastChannel===ch.id? ' active':'');
    div.textContent = ch.name;
    div.onclick = ()=>{ appState.lastChannel = ch.id; saveApp(); renderChannels(); renderMessages(); renderHeader(); if(usingServer && socket){ socket.emit('join', ch.id); } };
    channelsWrap.appendChild(div);
  });
}
function renderUsers(){
  usersWrap.innerHTML = '';
  const list = Object.keys(users);
  if(list.length===0){ usersWrap.textContent = '–ü–æ–∫–∞ –Ω–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π'; return; }
  list.forEach(u=>{
    const row = document.createElement('div');
    row.className = 'user-row';
    const img = document.createElement('img');
    img.className = 'avatar';
    img.src = getUserAvatar(u);
    img.alt = u;
    const name = document.createElement('div');
    name.textContent = u;
    row.appendChild(img);
    row.appendChild(name);
    usersWrap.appendChild(row);
  });
}
function formatTime(ts){ const d=new Date(ts); return d.toLocaleTimeString(); }

function renderMessages(){
  const ch = appState.lastChannel || 'general';
  ensureChannel(ch);
  const list = messages[ch] || [];
  messagesWrap.innerHTML = '';
  list.forEach(m=>{
    const row = document.createElement('div'); row.className = 'msg-row';
    const avatar = document.createElement('img'); avatar.className = 'avatar'; avatar.src = getUserAvatar(m.user); avatar.alt = m.user;
    const el = document.createElement('div');
    el.className = 'msg' + (m.user===currentUser? ' me':'') + (m.hidden? ' hidden':'');
    el.dataset.msgId = m.id;
    el.dataset.channel = ch;

    const meta = document.createElement('div'); meta.className = 'msg-meta'; meta.textContent = m.user + ' ‚Ä¢ ' + formatTime(m.ts);
    el.appendChild(meta);

    if(m.hidden){
      const ph = document.createElement('div'); ph.className = 'placeholder-hidden'; ph.textContent = '–°–æ–æ–±—â–µ–Ω–∏–µ —Å–∫—Ä—ã—Ç–æ';
      el.appendChild(ph);
    } else {
      if(m.text){
        const t = document.createElement('div'); t.style.marginTop='6px'; t.innerHTML = linkify(m.text); el.appendChild(t);
      }
      if(m.image){
        const img = document.createElement('img'); img.src = m.image; img.className = 'msg-img'; img.alt = 'image';
        img.onclick = ()=> window.open(m.image, '_blank', 'noopener'); el.appendChild(img);
      }
    }

    const btn = document.createElement('button'); btn.className = 'three-dots'; btn.innerText = '‚ãØ';
    btn.title = '–ú–µ–Ω—é —Å–æ–æ–±—â–µ–Ω–∏—è';
    btn.dataset.msgId = m.id;
    btn.dataset.channel = ch;
    btn.onclick = (e)=>{ e.stopPropagation(); openMessageMenu(btn, m, ch); };

    if(m.user === currentUser){
      row.appendChild(el);
      row.appendChild(avatar);
      row.appendChild(btn);
    } else {
      row.appendChild(avatar);
      row.appendChild(el);
      row.appendChild(btn);
    }
    messagesWrap.appendChild(row);
  });
  messagesWrap.scrollTop = messagesWrap.scrollHeight;
}
function renderHeader(){
  const ch = CHANNELS.find(c=>c.id===appState.lastChannel) || CHANNELS[0];
  channelTitle.textContent = ch.name;
  qs('channelDesc').textContent = ch.desc;
}

/* ======= Message menu actions ======= */
function openMessageMenu(button, message, channel){
  if(activeMenu){ activeMenu.remove(); activeMenu=null; }
  const rect = button.getBoundingClientRect();
  const menu = document.createElement('div'); menu.className = 'menu';
  // options
  if(message.hidden){
    const showBtn = document.createElement('button'); showBtn.textContent = '–ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ';
    showBtn.onclick = (ev)=>{ ev.stopPropagation(); toggleHidden(message.id, channel, false); closeMenu(); };
    menu.appendChild(showBtn);
  } else {
    const hideBtn = document.createElement('button'); hideBtn.textContent = '–°–∫—Ä—ã—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ';
    hideBtn.onclick = (ev)=>{ ev.stopPropagation(); toggleHidden(message.id, channel, true); closeMenu(); };
    menu.appendChild(hideBtn);
  }
  if(message.user === currentUser){
    const delBtn = document.createElement('button'); delBtn.textContent = '–£–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ'; delBtn.className='danger';
    delBtn.onclick = (ev)=>{ ev.stopPropagation(); if(confirm('–£–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ?')) { deleteMessage(channel, message.id); } closeMenu(); };
    menu.appendChild(delBtn);
  }
  const left = Math.min(window.innerWidth - 220, rect.right + 6);
  const top = rect.bottom + 6;
  menu.style.left = left + 'px'; menu.style.top = top + 'px';
  document.body.appendChild(menu); activeMenu = menu;
}
function closeMenu(){ if(activeMenu){ activeMenu.remove(); activeMenu=null; } }

/* ======= Message actions (server or local) ======= */
async function toggleHidden(msgId, channel, hide){
  if(usingServer && socket && socket.connected && SERVER_URL){
    try{
      // call REST toggle endpoint if available
      const url = SERVER_URL.replace(/\/$/,'') + `/api/messages/${encodeURIComponent(channel)}/${encodeURIComponent(msgId)}/toggleHidden`;
      const res = await fetch(url, { method:'POST', headers: { 'Authorization': 'Bearer ' + (token||'') } });
      if(res.ok){ const json = await res.json(); // server will broadcast message_updated
        // local update will happen via socket or storage event; but also apply locally
        const idx = msgIndexById(channel, msgId); if(idx!==-1){ messages[channel][idx] = json.message; saveMessages(); renderMessages(); }
      } else {
        throw new Error('toggle failed');
      }
      return;
    } catch(e){ /* fallback to local */ }
  }
  // local mode: toggle and broadcast
  const idx = msgIndexById(channel, msgId);
  if(idx === -1) return;
  messages[channel][idx].hidden = !!hide;
  saveMessages();
  if(usingServer===false) broadcastLocal({ type:'update_message', channel, message: messages[channel][idx] });
  renderMessages();
}

async function deleteMessage(channel, msgId){
  if(usingServer && socket && socket.connected && SERVER_URL){
    try{
      // try REST delete
      const url = SERVER_URL.replace(/\/$/,'') + `/api/messages/${encodeURIComponent(channel)}/${encodeURIComponent(msgId)}`;
      const res = await fetch(url, { method:'DELETE', headers: { 'Authorization': 'Bearer ' + (token||'') } });
      if(res.ok){ /* server broadcasts deletion */ return; }
      // else try socket delete
      socket.emit('delete_message', { channel, id: msgId }, (ack)=>{ if(ack && ack.ok) return; });
    } catch(e){ /* fallback to local */ }
  }
  // local delete
  const idx = msgIndexById(channel, msgId);
  if(idx === -1) return;
  const m = messages[channel][idx];
  if(m.user !== currentUser){ alert('–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å —á—É–∂–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ'); return; }
  messages[channel].splice(idx,1);
  saveMessages();
  if(usingServer===false) broadcastLocal({ type:'delete_message', channel, id: msgId });
  renderMessages();
}

/* ======= Send message (upload image to server when available) ======= */
btnAttach.onclick = ()=> imageFile.click();
imageFile.addEventListener('change', async (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  if(!f.type.startsWith('image/')) { alert('–í—ã–±–µ—Ä–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ'); return; }
  // preview small
  const data = await readFileAsDataURL(f);
  imgPreview.src = data; imgPreview.style.display = 'block'; imgPreview.dataset.dataurl = data; imageFile._file = f;
});
imgPreview.onclick = ()=> { if(confirm('–£–¥–∞–ª–∏—Ç—å –ø—Ä–∏–∫—Ä–µ–ø–ª—ë–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ?')) clearImagePreview(); }
function clearImagePreview(){ imgPreview.src = ''; imgPreview.style.display='none'; delete imgPreview.dataset.dataurl; imageFile.value = ''; imageFile._file = null; }

async function uploadFileToServer(file, field='file'){
  if(!SERVER_URL) throw new Error('no server');
  const fd = new FormData(); fd.append(field, file);
  const url = SERVER_URL.replace(/\/$/,'') + '/api/upload';
  const res = await fetch(url, { method:'POST', body: fd, headers: { 'Authorization': 'Bearer ' + (token||'') } });
  if(!res.ok) throw new Error('upload failed');
  const j = await res.json();
  return j.url || j;
}

btnSend.onclick = async ()=>{
  const text = inputMessage.value.trim();
  const file = imageFile._file || null;
  if(!currentUser){ alert('–°–Ω–∞—á–∞–ª–∞ –≤–æ–π–¥–∏—Ç–µ'); return; }
  if(!text && !file) return;
  const ch = appState.lastChannel || 'general';
  ensureChannel(ch);

  let imageUrl = null;
  if(file && SERVER_URL && token){
    try {
      imageUrl = await uploadFileToServer(file, 'file'); // returns server URL (e.g., /uploads/...)
      // convert to absolute if server provided relative path
      if(imageUrl && imageUrl.startsWith('/')) imageUrl = SERVER_URL.replace(/\/$/,'') + imageUrl;
    } catch(e){
      // fallback: embed as data URL (local prototype)
      imageUrl = await readFileAsDataURL(file);
    }
  } else if(file) {
    imageUrl = await readFileAsDataURL(file);
  }

  // send via server socket if available
  if(usingServer && socket && socket.connected){
    socket.emit('new_message', { channel: ch, text, imageUrl }, (ack)=>{
      if(ack && ack.message){
        // server will broadcast; but also apply local
        ensureChannel(ch);
        if(!messages[ch].some(m=>m.id===ack.message.id)){ messages[ch].push(ack.message); saveMessages(); renderMessages(); }
      }
    });
  } else {
    // local create and broadcast
    const msg = createMessageObject(currentUser, text, imageUrl);
    messages[ch].push(msg);
    saveMessages();
    broadcastLocal({ type:'new_message', channel: ch, message: msg });
    renderMessages();
  }

  inputMessage.value = ''; clearImagePreview();
};

/* ======= Auth / register / profile (server-enabled if SERVER_URL set) ======= */
async function registerUserLocal(username, password, avatarData){
  username = username.trim();
  if(!username || !password) throw '–í–≤–µ–¥–∏—Ç–µ –∏–º—è –∏ –ø–∞—Ä–æ–ª—å';
  if(users[username]) throw '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç';
  const hash = await sha256Hex(username + '|' + password);
  users[username] = { hash, createdAt: Date.now(), avatar: avatarData || null };
  saveUsers();
  return { username };
}
async function loginUserLocal(username, password){
  username = username.trim();
  if(!users[username]) throw '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω';
  const hash = await sha256Hex(username + '|' + password);
  if(hash !== users[username].hash) throw '–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å';
  return { username };
}

async function registerHandler(){
  try{
    const u = qs('regUser').value.trim();
    const p = qs('regPass').value;
    const p2 = qs('regPass2').value;
    if(p !== p2) { qs('regMsg').textContent = '–ü–∞—Ä–æ–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç'; return; }
    let avatarData = null;
    const f = regAvatarFile.files && regAvatarFile.files[0];
    if(f){
      if(!f.type.startsWith('image/')){ qs('regMsg').textContent = '–§–∞–π–ª –Ω–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ'; return; }
      if(SERVER_URL){
        // upload avatar to server
        try{
          const fd = new FormData(); fd.append('avatar', f);
          const url = SERVER_URL.replace(/\/$/,'') + '/api/register';
          // server expects username/password form fields; use fetch with form (server example: register endpoint used earlier expects multipart)
          fd.append('username', u); fd.append('password', p);
          const res = await fetch(url, { method: 'POST', body: fd });
          if(!res.ok){ const j = await res.json().catch(()=>{}); qs('regMsg').textContent = j && j.error ? j.error : '–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å'; return; }
          const j = await res.json();
          // server returns token and user
          saveToken(j.token);
          users[j.user.username] = users[j.user.username] || { hash: null, createdAt: Date.now(), avatar: j.user.avatarUrl || null };
          saveUsers();
          qs('regMsg').textContent = '–ì–æ—Ç–æ–≤–æ. –í—ã–ø–æ–ª–Ω–µ–Ω –≤—Ö–æ–¥.';
          // finish login
          await postLogin(j.user.username, j.token);
          return;
        }catch(err){
          qs('regMsg').textContent = '–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ, –ø—Ä–æ–±—É—é –ª–æ–∫–∞–ª—å–Ω–æ';
        }
      }
      avatarData = await readFileAsDataURL(f);
    }
    // local register
    await registerUserLocal(u,p,avatarData);
    qs('regMsg').textContent = '–ì–æ—Ç–æ–≤–æ. –¢–µ–ø–µ—Ä—å –≤–æ–π–¥–∏—Ç–µ (–ª–æ–∫–∞–ª—å–Ω–æ).';
    loginForm.style.display='block'; registerForm.style.display='none'; qs('authTitle').textContent='–í—Ö–æ–¥ / –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è';
    qs('loginUser').value = u;
  }catch(err){ qs('regMsg').textContent = String(err); }
}

async function loginHandler(){
  try{
    const u = qs('loginUser').value.trim();
    const p = qs('loginPass').value;
    if(SERVER_URL){
      try{
        const res = await fetch(SERVER_URL.replace(/\/$/,'') + '/api/login', { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ username: u, password: p }) });
        if(!res.ok){ const j = await res.json().catch(()=>{}); throw new Error(j && j.error ? j.error : '–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞'); }
        const j = await res.json();
        await postLogin(j.user.username, j.token);
        return;
      }catch(e){
        // fallback to local
      }
    }
    const r = await loginUserLocal(u,p);
    await postLogin(r.username, null);
  }catch(err){ alert(String(err)); }
}

async function postLogin(username, newToken){
  currentUser = username;
  saveToken(newToken || null);
  currentUserLabel.textContent = currentUser;
  currentUserBio.textContent = users[currentUser] && users[currentUser].avatar ? '–ê–≤–∞—Ç–∞—Ä —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω' : '–ê–≤–∞—Ç–∞—Ä –Ω–µ –∑–∞–¥–∞–Ω';
  sidebarAvatar.src = getUserAvatar(currentUser);
  authModal.style.display = 'none';
  renderUsers();
  renderMessages();
  renderHeader();
  // connect realtime after login if server configured
  if(SERVER_URL){ await connectRealtime(); }
}

/* Profile handlers (update avatar) */
regAvatarFile.addEventListener('change', async ()=>{ /* noop; handled on submit */ });
profileAvatarFile.addEventListener('change', async (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  if(!f.type.startsWith('image/')) { alert('–í—ã–±–µ—Ä–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ'); profileAvatarFile.value=''; return; }
  const data = await readFileAsDataURL(f);
  profileAvatarPreview.src = data;
});

btnOpenProfile.onclick = ()=>{
  if(!currentUser){ alert('–°–Ω–∞—á–∞–ª–∞ –≤–æ–π–¥–∏—Ç–µ'); return; }
  profileForm.style.display = 'block'; registerForm.style.display='none'; loginForm.style.display='none';
  profileUserInput.value = currentUser;
  profileAvatarPreview.src = getUserAvatar(currentUser);
  authModal.style.display = 'flex';
};
btnCloseProfile.onclick = ()=>{ authModal.style.display = 'none'; profileForm.style.display='none'; loginForm.style.display='block'; };

btnSaveAvatar.onclick = async ()=>{
  if(!currentUser) return;
  const f = profileAvatarFile.files && profileAvatarFile.files[0];
  let data = null;
  if(f && SERVER_URL && token){
    try{
      // upload to server
      const fd = new FormData(); fd.append('avatar', f);
      const res = await fetch(SERVER_URL.replace(/\/$/,'') + '/api/avatar', { method:'POST', body: fd, headers: { 'Authorization': 'Bearer ' + (token||'') } });
      if(res.ok){ const j = await res.json(); const avatarUrl = j.avatarUrl || j; // may be relative
        // make absolute if starts with '/'
        const abs = avatarUrl.startsWith('/') ? SERVER_URL.replace(/\/$/,'') + avatarUrl : avatarUrl;
        users[currentUser].avatar = abs;
        saveUsers();
        sidebarAvatar.src = getUserAvatar(currentUser);
        renderUsers();
        alert('–ê–≤–∞—Ç–∞—Ä —Å–æ—Ö—Ä–∞–Ω—ë–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ');
        return;
      }
    }catch(e){}
  }
  if(f){
    data = await readFileAsDataURL(f);
    users[currentUser].avatar = data;
    saveUsers(); sidebarAvatar.src = getUserAvatar(currentUser); renderUsers(); alert('–ê–≤–∞—Ç–∞—Ä —Å–æ—Ö—Ä–∞–Ω—ë–Ω (–ª–æ–∫–∞–ª—å–Ω–æ)');
  } else {
    const preview = profileAvatarPreview.src;
    if(preview && preview !== DEFAULT_AVATAR){ users[currentUser].avatar = preview; saveUsers(); sidebarAvatar.src = getUserAvatar(currentUser); renderUsers(); alert('–ê–≤–∞—Ç–∞—Ä —Å–æ—Ö—Ä–∞–Ω—ë–Ω (–ª–æ–∫–∞–ª—å–Ω–æ)'); }
  }
};
btnRemoveAvatar.onclick = ()=>{
  if(!currentUser) return;
  users[currentUser].avatar = null; saveUsers(); sidebarAvatar.src = DEFAULT_AVATAR; profileAvatarPreview.src = DEFAULT_AVATAR; renderUsers(); alert('–ê–≤–∞—Ç–∞—Ä —É–¥–∞–ª—ë–Ω');
};

/* ======= Storage sync (local fallback) ======= */
window.addEventListener('storage', (ev)=>{
  if(ev.key === USERS_KEY && ev.newValue){ try{ users = JSON.parse(ev.newValue); renderUsers(); }catch(e){} }
  if(ev.key === MESSAGES_KEY && ev.newValue){ try{ messages = JSON.parse(ev.newValue); renderMessages(); }catch(e){} }
  if(ev.key === 'sm_last_broadcast_v3' && ev.newValue){
    try{ const env = JSON.parse(ev.newValue); handleLocalBroadcast(env); }catch(e){} }
});

/* ======= UI wiring and init ======= */
qs('toRegister').onclick = (e)=>{ e.preventDefault(); loginForm.style.display='none'; registerForm.style.display='block'; profileForm.style.display='none'; qs('authTitle').textContent='–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è'; }
qs('toLogin').onclick = (e)=>{ e.preventDefault(); loginForm.style.display='block'; registerForm.style.display='none'; profileForm.style.display='none'; qs('authTitle').textContent='–í—Ö–æ–¥ / –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è'; }
btnRegister.onclick = registerHandler;
btnLogin.onclick = loginHandler;
btnLogout.onclick = ()=>{ currentUser = null; currentUserLabel.textContent = '‚Äî'; currentUserBio.textContent = '‚Äî'; sidebarAvatar.src = DEFAULT_AVATAR; saveToken(null); authModal.style.display = 'flex'; };

setInterval(()=>{ serverTime.textContent = new Date().toLocaleTimeString(); }, 1000);

/* startup */
(async function init(){
  CHANNELS.forEach(c=>{ if(!messages[c.id]) messages[c.id]=[]; });
  saveMessages(); saveUsers(); saveApp();
  renderChannels(); renderUsers(); renderHeader();
  // auto-login if token and SERVER_URL -> try to fetch user info (assuming server supports token introspect via /api/me optional)
  if(token && SERVER_URL){
    try{
      // try fetching user identity using token via /api/me (if server supports) or by requesting /api/messages to get user list
      // fallback: try to decode token with basic base64 (not secure). We'll just attempt to connect socket with token and request nothing.
      await connectRealtime();
      // if socket connected and server provides user details via /api/me, you'd fetch here. For now, show logged-in from token presence if local users unknown
      const lastUser = localStorage.getItem('sm_last_user_v3');
      if(lastUser) { currentUser = lastUser; currentUserLabel.textContent = currentUser; sidebarAvatar.src = getUserAvatar(currentUser); authModal.style.display='none'; }
    }catch(e){}
  } else {
    // try local remembered user
    const u = localStorage.getItem('sm_last_user_v3');
    if(u && users[u]){ currentUser = u; currentUserLabel.textContent = currentUser; sidebarAvatar.src = getUserAvatar(currentUser); authModal.style.display='none'; }
  }
  if(!currentUser) authModal.style.display = 'flex'; else authModal.style.display = 'none';
  // start realtime (local or server) after init
  await connectRealtime();
  setTimeout(renderMessages, 60);
})();

/* =================== END =================== */
</script>
</body>
</html>
